<html>
<head>
	<title>Linux Assembly Tutorial - Step-by-Step Guide</title>
	<style>
	.term { color: #D0D0D0; background-color: #000000; width: 500px; padding: 10 10 10 5 }
	.type { background-color: #D0D0D0 }
	</style>
	<!-- This document consists entirely of unadulterated, hand-coded HTML,
	     written character-for-character in a l33t Linux text editor. -->
</head>

<body>
<h1 align="center">Linux Assembly Tutorial</h1>
<h2 align="center">Step-by-Step Guide</h2>
<p>
Written by: Derick Swanepoel (<a href="mailto:derick@maple.up.ac.za">derick@maple.up.ac.za</a>)<br>
Version 1.0 - 2002-04-19, 01:50am<br>
<br>
<a href="asmtut.tgz">Download as zipfile</a><br>
<br>
<tt>JMP </tt> <a href="quickstart.html">Quickstart</a><br>
</p>

<dl><h2>Contents</h2>
	<dt>1. <a href="#intro">Introduction</a></dt>
	<dt>2. <a href="#why">Why this Tutorial?</a></dt>
	<dt>3. The Netwide Assembler (NASM)</dt>
	<dd><dl>
		<dt>3.1 <a href="#nasm.note">A Note on Assemblers</a></dt>
		<dt>3.2 <a href="#nasm.where">Where do I get NASM?</a></dt>
	</dl></dd>
	<dt>4. Introduction to Linux Assembly</dt>
	<dd><dl>
		<dt>4.1 <a href="#maindiff">Main Differences Between DOS and Linux Assembly</a></dt>
		<dt>4.2 <a href="#parts">The Parts of an Assembly Program</a></dt>
		<dt>4.3 <a href="#syscalls">Linux System Calls</a></dt>
		<dd><dl>
			<dt>4.3.1 <a href="#manpages">Reading the Manpages</a></dt>
		</dl></dd>
		<dt>4.4 <a href="#helloworld">"Hello World!" in Linux Assembly</a></dt>
		<dt>4.5 <a href="#compiling">Compiling and Linking</a></dt>
	</dl></dd>
	<dt>5. <a href="#advanced">More Advanced Concepts</a></dt>
	<dd><dl>
		<dt>5.1 <a href="#stack">Command Line Arguments and the Stack</a></dt>
		<dt>5.2 <a href="#procedures">"Procedures" and Jumping</a></dt>
	</dl></dd>
	<dt>6. <a href="#conclusion">Conclusion</a></dt>
	<br>
	<dt>Appendix A. <a href="#terminal">The terminal is your friend - how to use it</a></dt>
	<dt>Appendix B. <a href="#installingnasm">Installing NASM (and other stuff) on Linux</a></dt>
	<dt>Appendix C. <a href="#references">References</a></dt>
</dl>
<hr>

<a name="intro">&nbsp;</a>
<h2>1. Introduction</h2>
<p>This tutorial is an introduction to coding assembly in Linux. There are two "versions" to accommodate
various people:
<ul>
	<li>The Step-by-Step Guide: This version explains everything in detail. It assumes that you have done at
	least a little bit of DOS assembly, and that you have Linux on your computer (although you may not have
	used it much yet). Since not everyone may know how to use Linux, there are links to sections where I explain
	how to do basic things like use the terminal and the DOS-equivalent commands.
	<li><a href="quickstart.html">The Quickstart</a>: If you're in a hurry and just want to see a Linux
	assembly program, compile it and run it, this is for you. It assumes that you understand basic DOS assembly,
	and that you know how to use the terminal. Basically, it just points out the differences between a Linux and
	DOS assembly program with just enough explanation not to confuse you.
	<!--<li><a href="advanced.html">The Advanced Tut</a>: This part assumes you know Linux, and focusses entirely
	on the assembly part. The important sections from the Step-by-Step Guide are included, but in less detail.-->
</ul>
The assembler I'll be using is NASM (Netwide Assembler). Lots of the stuff in this tutorial came from other
tuts and the NASM documentation &ndash; see the References section for more info.</p>

<a name="why">&nbsp;</a>
<h2>2. Why this Tutorial?</h2>
<p><b>Mainly, the reason for this tutorial is to make assembly programming easier, better and more practical
by doing it in Linux instead of DOS. Also, it may teach you a bit of Linux while you're at it (unless you're already
at home with it).</b></p>
<p>Programming in assembly may seem quite masochistic (and writing entire programs in it simply ridiculous),
especially in these days of super-optimizing compilers and visual development tools that do just about everything
for you. However, there is an advantage in understanding more about the inner workings of your processor and
kernel, and assembly is a good way of learning this. Sometimes assembly can be extremely useful for sticking inline
in a C/C++ program. And if your program <i>really</i> has a "need for speed", you can tweak and optimize
the assembly generated by the compiler (of course, you need to be pretty elite to produce better code than today's
compilers.)</p>
<p>Since there was this notion that we were to be taught how to use Linux during COS284 (sort of as an aside),
the idea was that we would code assembly in Linux. But not Linux assembly - DOS assembly, in a DOS emulator,
with a DOS text editor. Of course, this entirely defeats the purpose, but maybe it was to be done this way mainly
because there aren't so many Linux assembly tutorials and sample code as for DOS. Well, here is a tutorial that'll
teach you the basics of Linux assembly.
</p>
<br>

<h2>3. The Netwide Assembler (NASM)</h2></a>
<h3><a name="nasm.note">3.1 A Note on Assemblers</a></h3>
<p>Linux will almost always be intalled with the default assemblers <tt>as</tt> and <tt>as86</tt> available, and
quite likely also <tt>gas</tt>. However, we will be using NASM, the Netwide Assembler. It uses the Intel syntax
just like TASM, MASM, and other DOS assemblers, and the structure is also fairly similar. (Useless info: <tt>as</tt> and
<tt>gas</tt> use the AT&amp;T syntax, which is somewhat different &ndash; eg. all registers must be prefixed
with a %, and the source operand comes before the destination. See the References for a link to a tut using <tt>as</tt>
and AT&amp;T syntax.)</p>
<p>NASM is cool because it's portable (there are Linux, Unix and DOS versions), it's free and it's powerful with lots of
nice features. Trust me.</p>

<h3><a name="nasm.where">3.2 Where do I get NASM?</a></h3>
<p>If you selected "Development Tools" when you installed Linux, chances are you already have NASM. It comes
standard with most Linux distributions, so you don't need to download it. To check if you've got it, just ask Linux,
"Where is NASM?" Here's how:</p>
<ol>
	<li>Open a terminal. (For some basic Linux terminal skills, go to
	<a href="#terminal">The terminal is your friend - how to use it</a>)
	<li>Type <tt>whereis nasm</tt> and press ENTER.
</ol>
<p>If you see a line that says something like <tt>nasm: /usr/bin/nasm</tt> then you're fine. If all you see is
<tt>nasm:     </tt> then you need to install NASM. <a href="#installingnasm">Here are some instructions</a> on how to
install NASM (or anything else) on Linux.</p>
<p>If you feel like getting the latest and greatest version of NASM, visit their website
<a href="http://www.cryogen.com/Nasm">www.cryogen.com/Nasm</a>, or get it with FTP from our local Linux
mirror <a href="ftp://ftp.kernel.za.org/pub/software/devel/nasm/binaries">ftp.kernel.za.org/pub/software/devel/nasm/binaries</a>.</p>
<br>

<h2>4. Introduction to Linux Assembly</h2></a>
<h3><a name="maindiff">4.1 Main Differences Between DOS and Linux Assembly</a></h3>
<p>
<ul>
	<li>In DOS assembly, most things get done with the DOS services interrupt <tt>int 21h</tt>, and the BIOS
	service interrupts like <tt>int 10h</tt> and <tt>int 16h</tt>. In Linux, all these functions are handled by the
	kernel. Everything gets done with "kernel system calls", and you call the kernel with <tt>int 80h</tt>. One of
	the wonderful things about Linux system calls are that there are fewer of them (about 190) than DOS, but they
	are far more practical (you don't have obsolete crap like functions that load casette BASIC and things left over
	from DOS 1.0). Linux system calls create files, handle processes and other such useful stuff - no strings attached
	(mmm, bad pun ;-)
	<li>Linux is a true, 32-bit protected mode operating system, so this enables us to do real, up-to-date 32-bit
	assembly. This 32-bit code runs in the <i>flat</i> memory model, which basically means you don't have to worry
	about segments at all. This makes life a lot easier, because you never need to use a segment override or modify
	any segment register, and every address is 32 bits long and contains only an offset part. (If this is just a lot of
	waffling to you, don't worry, just know that it's good and will simplify things for you.)
	<li>In 32-bit assembly, you use the extended 32-bit registers <tt>EAX, EBX, ECX</tt> and so on instead of the normal
	16-bit registers <tt>AX, BX, CX</tt> etc.
	<li>DOS is dead. It's 16-bit. It's obsolete. The only people that still write DOS assembly are crazy old hackers that
	are too attached to their 386s to throw them away. Linux assembly has practical applications (parts of the OS are
	written in assembler, hardware drivers are often coded in assembler).
</ul>
</p>

<h3><a name="parts">4.2 The Parts of an Assembly Program</a></h3>
<p>An assembly program can be divided into three sections:
<ul>
	<li><b>The <tt>.data</tt> section</b><br><br>
	This section is for "declaring initialized data", in other words defining "variables" that already contain stuff.
	However this data does not change at runtime so they're not really variables. The <tt>.data</tt> section is used
	for things like filenames and buffer sizes, and you can also define constants using the <tt>EQU</tt> instruction.
	Here you can use the <tt>DB, DW, DD, DQ</tt> and <tt>DT</tt> instructions. For example:
<pre>
section .data
	message:    db 'Hello world!'     ; Declare message to contain the bytes 'Hello world!' (without quotes)
	msglength:  equ 12                ; Declare msglength to have the constant value 12
	buffersize: dw 1024               ; Declare buffersize to be a word containing 1024
</pre>

	<li><b>The <tt>.bss</tt> section</b><br><br>
	This section is where you declare your variables. You use the <tt>RESB, RESW, RESD, RESQ</tt> and <tt>REST</tt>
	instructions to reserve uninitialized space in memory for your variables, like this:
<pre>
section .bss
	filename:   resb    255           ; Reserve 255 bytes
	number:     resb    1             ; Reserve 1 byte
	bignum:     resw    1             ; Reserve 1 word (1 word = 2 bytes)
	realarray:  resq    10            ; Reserve an array of 10 reals
</pre>

	<li><b>The <tt>.text</tt> section</b><br><br>
	This is where the actual assembly code is written. The <tt>.text</tt> section must begin with the declaration
	<tt>global _start</tt>, which just tells the kernel where the program execution begins. (It's like the main
	function in C or Java, only it's not a function, just a starting point.) Eg.:
<pre>
section .text
	global _start

_start:
	pop    ebx        ; Here is the where the program actually begins
	.
	.
	.
</pre>
</ul>

As you can see, so far things are still more or less DOSish. Next we'll look at system calls in more detail,
and once that is done you'll be able to write your first Linux assembly program!
</p>

<h3><a name="syscalls">4.3 Linux System Calls</a></h3>
<p>Linux system calls are called in exactly the same way as DOS system calls:
<ol>
	<li>You put the system call number in <tt>EAX</tt> (we're dealing with 32-bit registers here, remember)
	<li>You set up the arguments to the system call in <tt>EBX, ECX</tt>, etc.
	<li>You call the relevant interrupt (for DOS, <tt>21h</tt>; for Linux, <tt>80h</tt>)
	<li>The result is usually returned in <tt>EAX</tt>
</ol>
There are six registers that are used for the arguments that the system call takes. The first argument goes
in EBX, the second in ECX, then EDX, ESI, EDI, and finally EBP, if there are so many. If there are more than
six arguments, EBX must contain the memory location where the list of arguments is stored - but don't worry
about this because it's unlikely that you'll use a syscall with more than six arguments. The wonderful thing
about this scheme is that Linux uses it consistently &ndash; all system calls are designed this way, there
are no confusing exceptions.</p>
<p>
Some example code always helps:
<pre>
	mov	eax,1       ; The exit syscall number
	mov	ebx,0       ; Have an exit code of 0
	int	80h         ; Interrupt 80h, the thing that pokes the kernel and says, "Yo, do this"
</pre>
</p>
<p>
But how do you find out what these system calls are, and what they do, and what arguments they take?
Firstly, all the syscalls are listed in <tt>/usr/include/asm/unistd.h</tt>, together with their numbers
(the value to put in <tt>EAX</tt> before you call <tt>int 80h</tt>). However, for your convenience you
can simply find them in this <a href="syscalls.html">Linux System Call Table</a>, together with some
other useful information (eg. what arguments they take). Take a look at the list of syscalls &ndash;
there are things like <tt>sys_write</tt> (4), <tt>sys_nice</tt> (34) and of course <tt>sys_exit</tt> (1).
To find out just what these things do, you can look them up in the <u>Linux manual pages</u> (commonly
called "the manpages"). That is what the next section is about.</p>

<h4><a name="manpages">4.3.1 Reading the Manpages</a></h4>
<p>
First, open a terminal (or switch to one of the 6 consoles with <tt>CTRL+ALT+F1</tt> through <tt>F6</tt>
- to get back to graphical mode press <tt>CTRL+ALT+F7</tt>). Say now you want to know what the "write"
syscall does. Type <tt>man 2 write</tt> and press ENTER. This will bring up the manual page on "write"
from section 2 of the manpages.</p>
<p>
Under the <b>NAME</b> section is the syscall's name and what it does &ndash; in this case:
<pre>write - write to a file descriptor</pre>
This is the syscall you use to write to, well, a file. But you also use it to print stuff on the screen.
"Why the heck is that?" you ask. See, in Linux everything is a file. Things like the screen, mice, printers,
etc. are special files called "device files", but you read and write to them just like you do to a text file.
This actually makes sense, because reading/writing files is one of the simplest things to do in programming,
so why not do everything in the same simple way - but I digress.</p>
<p>
Next, under the <b>SYNOPSIS</b> section you see a fairly ugly line:
<pre>ssize_t write(int <u>fd</u>, const void *<u>buf</u>, size_t <u>count</u>);</pre>
OK, if you know C it won't be ugly, because this is just the C definition of the syscall. As you can see,
it takes three arguments: the file descriptor, followed by the buffer, and then how many bytes to write,
which should be however long the buffer is. (The <b>DESCRIPTION</b> section tells us what the arguments are
for.) The file descriptor (<tt>fd</tt>) is an integer, the buffer (<tt>buf</tt>) is a pointer to a memory
location (that's what the * means), so it's also an integer, and the bytes to write (<tt>count</tt>) is of
type size_t, which is also an integer. This makes sense because we put values for these arguments in the
registers EBX, ECX and EDX, which are all 32-bit integers. Finally, the write syscall returns a value in EAX:
the number of bytes actually written. This can be used to verify if all went well.</p>
<p>
Now we can finally write our first Linux assembly program!</p>

<h3><a name="helloworld">4.4 "Hello World!" in Linux Assembly</a></h3>
<p>Of course, the appropriate way to begin would be to print out "Hello world!" To print to the screen, we write
to the special file called STDOUT (standard output), which is file descriptor 1. Here is the program in full:</p>
<pre style="background-color: #00D0FF">
section .data
	hello:     db 'Hello world!',10    ; 'Hello world!' plus a linefeed character
	helloLen:  equ $-hello             ; Length of the 'Hello world!' string
	                                   ; (I'll explain soon)

section .text
	global _start

_start:
	mov eax,4            ; The system call for write (sys_write)
	mov ebx,1            ; File descriptor 1 - standard output
	mov ecx,hello        ; Put the offset of hello in ecx
	mov edx,helloLen     ; helloLen is a constant, so we don't need to say
	                     ;  mov edx,[helloLen] to get it's actual value
	int 80h              ; Call the kernel

	mov eax,1            ; The system call for exit (sys_exit)
	mov ebx,0            ; Exit with return code of 0 (no error)
	int 80h
</pre>

<p>Copy this program into a text editor of your choice (I use <tt>vi</tt> or <a href="http://www.scintilla.org/SciTE.html">SciTE</a>),
and save it as <tt>hello.asm</tt> in your home directory (<tt>/home/<i>yourname</i></tt>).</p>

<h3><a name="compiling">4.5 Compiling and Linking</a></h3>
<p>
<ol>
	<li>If you don't have a terminal or console open, open one now.
	<li>Make sure you are in the same directory as where you saved <tt>hello.asm</tt>.
	<li>To assemble the program, type<br>
	<tt>nasm -f elf hello.asm</tt><br>
	If there are any errors, NASM will tell you on what line you did what wrong.
	<li>Now type <tt>ld -s -o hello hello.o</tt><br>
	This will link the object file NASM produced into an executable file.
	<li>Run your program by typing <tt>./hello</tt><br>
	(To run programs/scripts in the current directory, you must always type <tt>./</tt> before the name,
	unless the current directory is in the path.)
</ol>
You should see <tt>Hello world!</tt> printed to the screen. Congratulations! You have just written your
first assembly program in Linux!</p>

<a name="advanced">&nbsp;</a>
<h2>5. More Advanced Concepts</h2>
<p>
Before I go on, you're probably wondering what that <tt>equ $-hello</tt> thing is doing in our
Hello World program (line 3). As you may remember, when you use <tt>equ</tt> to declare a variable (instead of
<tt>db</tt>, for example), you are actually declaring a constant. Declaring the length of our string as a
constant is sensible because it sure isn't going to change. But how does <tt>$-hello</tt> turn out to be the
length of 'Hello world!' ? When NASM sees a '$' it replaces it with the assembly position at the beginning of
that line. (That is also the position at the end of the previous line.) So subtracting the position of a variable
from '$' will give us the number of bytes between the variable and '$'. If we want to declare a variable that
contains the length of a string we've declared by saying <tt>hello: db 'Hello world!',10</tt> then we just stick
<tt>helloLen: equ $-hello</tt> on the next line. That will make <tt>helloLen</tt> equal to the number of bytes
that <tt>hello</tt> takes up in memory, which in this case is 13 (the linefeed character also counts). Don't
worry if this confuses you &ndash; just remember that it's a neat and easy way to declare the length of a string.
</p>

<p>If you're more than just casually interested, I'd encourage you to check out the NASM documentation for more
information on these things, and how to use some of the other neat features that I'm not going to mention in
this tutorial.</p>

<h3><a name="stack">5.1 Command Line Arguments and the Stack</a></h3>
<p>
Getting the command line arguments from a DOS program is not an enjoyable experience, because working with the
PSP and having to worry about segments is simply a pain. In Linux things are much simpler: all arguments are
available on the stack when the program starts, so to get them you just <tt>pop</tt> them off.</p>
<p>
As an example, say you run a program called <tt>program</tt> and give it three arguments:
<pre>
./program foo bar 42
</pre>
The stack will then look as follows:<br>
<table cellspacing=10>
<tr>
	<td><table cellpadding=3 border=1 height=150 style="text-align: center; font-family: monospace; background-color: #EAEAEA">
	<tr><td>4</td></tr>
	<tr><td>program</td></tr>
	<tr><td>foo</td></tr>
	<tr><td>bar</td></tr>
	<tr><td>42</td></tr>
	</table>
	</td>
	<td><table cellpadding=3 height=150>
	<tr><td>Number of arguments (argc), including the program name</td></tr>
	<tr><td>Name of the program (argv[0])</td></tr>
	<tr><td>Argument 1, the first real argument (argv[1])</td></tr>
	<tr><td>Argument 2 (argv[2])</td></tr>
	<tr><td>Argument 3 (argv[3]) (Note: this is the string "42", not the number 42)</td></tr>
	</table>
	</td>
</tr>
</table>
</p>
<p>Now lets write the program <tt>program</tt> that takes the three arguments:
<pre style="background-color: #00D0FF">
section .text
	global _start

_start:
	pop	eax		; Get the number of arguments
	pop	ebx		; Get the program name
	pop	ebx		; Get the first actual argument ("foo")
	pop	ecx		; "bar"
	pop	edx		; "42"

	mov	eax,1
	mov	ebx,0
	int	80h		; Exit
</pre>
After all that popping, EAX contains the number of arguments, EBX points to wherever "foo" is stored
in memory, ECX points to "bar" and EDX to "42". This is obviously <i>way</i> more elegant and simple
than in DOS. It took us just 5 lines to get the arguments and even how many there are, while in DOS it
takes 14 rather complicated lines just to get <i>one</i> argument! Note that the 3<sup>rd</sup> <tt>pop</tt>
overwrites the value we put in EBX with the 2<sup>nd</sup> <tt>pop</tt> (which was the program name).
Unless you have a really good reason, you can usually chuck away the program name as we did here.
</p>

<h3><a name="procedures">5.2 "Procedures" and Jumping</a></h3>
<p>
<b>NB:</b> NASM doesn't have procedure definitions like you may have used in TASM. That's because procedures
don't really exist in assembly: everything is a label. So if you want to write a "procedure" in NASM,
you don't use <tt>proc</tt> and <tt>endp</tt>, but instead just put a label (eg. <tt>fileWrite:</tt>)
at the beginning of the "procedure's" code. If you want to, you can put comments at the start and end
of the code just to make it look a bit more like a procedure. Here's an example in both Linux and DOS:
<table cellspacing="10">
<tr>
	<td style="font-size: 14pt; text-align: center; background-color: #00D0FF">Linux</td>
	<td style="font-size: 14pt; text-align: center; background-color: #00FFC0">DOS</td>
</tr>
<tr>
	<td valign="top" style="background-color: #00D0FF"><pre>
; proc fileWrite - write a string to a file
fileWrite:
   mov eax,4               ; write system call
   mov ebx,[filedesc]      ; File descriptor
   mov ecx,stuffToWrite
   mov edx,[stuffLen]
   int 80h
   ret
; endp fileWrite
</pre></td>
	<td valign="top" style="background-color: #00FFC0"><pre>

proc fileWrite
   mov ah,40h              ; write DOS service
   mov bx,[filehandle]     ; File handle
   mov cl,[stuffLen]
   mov dx,offset stuffToWrite
   int 21h
   ret
endp fileWrite
</pre></td>
</table>
</p>

<p><b>NB<sup>2</sup>:</b> I assume that you're familiar with labels and jumping to them with instructions
like <tt>JMP</tt>, <tt>JE</tt> or <tt>JGE</tt>. Now that you've seen that "procedures" are actually labels,
there is one very important thing to remember: If you are planning to return from a procedure (with the
<tt>RET</tt> instruction), <b><i>don't jump to it!</i></b> As in "never!" Doing that will cause a segmentation
fault on Linux (which is OK &ndash; all your program does is terminate), but in DOS it may blow up in your
face with various degrees of terribleness. The rule to remember is:</p>
<p style="padding-left: 30px">You may <i>jump</i> to <i>labels</i>, but you must <u>call</u> a <u>procedure</u>.</p>
<p>
Calling a procedure is of course done with the <tt>CALL</tt> instruction. This makes life a bit difficult
when you want to do things like "if-then-else". If you have a situation such as "if this happens, call
procedure 1, else call procedure 2" there's only one thing to do: Jump around like a kangaroo weaving a
spaghetti code masterpiece. Lets look at an example. First, here is some normal, sane code:
<pre style="background-color: #FFFFA0">
	if (AX == 'w') {
	   writeFile();
	} else {
	   doSomethingElse();
	}
</pre>

This is how you would do it in assembly:

<pre style="background-color: #00D0FF">
	cmp	AX,'w'		; Does AX contain 'w'?
	jne	skipWrite	; If not, skip writing by jumping to another label, and doSomethingElse there...
	call	writeFile	; ...else call the writeFile procedure...
	jmp	outOfThisMess	; ...and jump past all of this spaghetti

skipWrite:
	call	doSomethingElse
outOfThisMess:
	...			; The rest of the program goes on here
</pre>

Note that this is applicable to any assembly, not just Linux or NASM.
</p>

<h3><a name="everything">5.3 A Program with Everything</a></h3>
<p>
Now we can finally take a look at a program that does something remotely useful, containing
almost everything we've covered. In the Quickstart version of this tutorial, I have included a
Linux and a DOS version of the program we wrote in Practical 3 (the one that writes 'Hello world!'
to the file given as a command line argument). <a href="quickstart.html#cmdarg_file">Check it out</a>
and see how much simpler and logical the Linux program is compared to the DOS one.</p>

<a name="conclusion">&nbsp;</a>
<h2>6. Conclusion</h2>
<p>
Well, that's about it for this tutorial. I hope this has been a suitable introduction to doing
assembly programming in Linux. If you have any questions, suggestions or problems, feel free to
e-mail me at <a href="mailto:derick@maple.up.ac.za">derick@maple.up.ac.za</a>. This is my first
tutorial and I'm no assembly hacker either, so I welcome your comments.<br>
<br>
Good luck and happy coding!
</p>

<hr>

<a name="terminal">&nbsp;</a>
<h2>Appendix A. The terminal is your friend - how to use it</h2>
<p>
The terminal / console is an integral and very useful part of Linux. Linux has an excellent set of
command line utilities and programs, and you can control the whole system without a GUI. Sometimes
this is actually easier and faster. For programming in assembly you are obviously going to have to
work in the terminal, and this part will show you how.
</p>

<p style="color: #FF0000">Before you start, keep in mind that Unix/Linux is case sensitive, so
"Blah" is not the same as "blah" or "blaH".</p>

<p>
<ul>
	<li><b>Opening a terminal:</b> If you're in KDE or Gnome, simply click on the terminal icon or
	browse the "Start"-menu for a terminal program. Alternatively you can switch to one of the 6 text-mode
	consoles by pressing <tt>CTRL+ALT+F1</tt> through <tt>F6</tt>. To get back to graphics mode press
	<tt>CTRL+ALT+F7</tt>. When you open a terminal or log in on a console, you are plonked into your
	home directory, which is called whatever your username is. You are presented with a prompt that
	looks something like this:
<pre class="term">
[delta@quantumcow asmtut]$
</pre>
	The part before the '@' tells you your username (mine is <b>delta</b>), then the computer name
	(<b>quantumcow</b>), and then the top-level current directory (<b>asmtut</b>).
	<li><b>Finding out where you are:</b> At the prompt, type <tt class=type>pwd</tt>. This will show you the
	"present working directory", in other words where you are now. For example:
<pre class="term">
[delta@quantumcow asmtut]$ pwd
/home/delta/asmtut
</pre>
	<li><b>Changing directories:</b> To change to another directory you use the <tt>cd</tt> command.
	Note that it works a bit different than the DOS <tt>cd</tt>. Firstly, there must be a space between
	"cd" and the directory name. Secondly, in Unix/Linux, the directory separator is a forward slash (/)
	not a backslash (\). To change to the parent directory of the current one, you go <tt class=type>cd ..</tt>.
	To go up two levels in the directory tree, type <tt class=type>cd ../..</tt>. Here are some examples &ndash; try them out:
<pre class="term">
[delta@quantumcow asmtut]$ cd /usr/share/doc
[delta@quantumcow doc]$ pwd
/usr/share/doc
[delta@quantumcow doc]$ cd ..
[delta@quantumcow share]$ cd ../..
[delta@quantumcow /]$
</pre>
	At the end of this example, you end up in the root directory, <tt>/</tt> (similar to C:\). Now to
	get back to your home directory, type <tt class=type>cd ~</tt><br>
	The tilde (~) is a shortcut for your home directory.
	<li><b>Finding out what's in a directory:</b> To list the current directory's contents, type <tt class=type>ls</tt>.
	If you're in your home directory and haven't used Linux much, there probably won't be many files.
	Change to a directory like <tt>/etc</tt> and list its contents &ndash; lots of files! (The /etc directory
	is where most of the system's configuration files are stored.) To get some more info, you can do a
	"long list" by typing <tt class=type>ls -l</tt> or simply <tt class=type>ll</tt>. In my home directory it looks like this:<br>
	<img src="terminal_ls.png" border=0><br>
	Directories are highlighted in blue, executable files in green, compressed archives in red and images in purple.
	<li><b>Finding out what's in a file:</b> You can use either <tt>cat</tt> or <tt>less</tt> to view the contents
	of a file. Use <tt>less</tt> when you know the output will be more than one screen long, because <tt>less</tt>
	will pause at every screen of text, and allows you to scroll up and down.
<pre class="term">
[delta@quantumcow asmtut]$ cat foo.txt
Hello, world!
</pre>
	<li><b>The wonders of tab-completion:</b> Linux has a wonderful feature called tab-completion. Almost anywhere,
	when you are typing in the name of a file or directory, you can press the <tt>TAB</tt> key and Linux will complete
	the name for you. This is especially useful when you're dealing with things that have long names. Try find a
	directory with really long directory names in it, and then <tt>cd</tt> to one of them using tab-completion.
	For example, type <tt class=type>cd /usr/share/doc/cons</tt> and press <tt>TAB</tt>. Tada! Linux has completed
	the name for you, (<tt>console-tools-19990829/</tt>) and you can just press <tt>ENTER</tt>.<br>
	<br>
	If you try typing <tt class=type>cd /usr/share/doc/proc</tt> and then press <tt>TAB</tt> you'll hear a beep. That's because
	there are more than one directory in /usr/share/doc that starts with "proc", so Linux doesn't know which one you
	want. If you press <tt>TAB</tt> again it will display the directories starting with "proc". Now you can type some
	more letters of the directory you want (just enough to identify it uniquely will do), and press <tt>TAB</tt> again.
	Neat, isn't it?
</ul>

It is often useful to have more than just one terminal open, for example one to compile your program in and another
to read manpages with. Also, most window managers (KDE, Gnome, IceWM are window managers) allow you to work on
multiple desktops. So when one desktop gets cluttered with windows, just go to another one and "start with a clean
slate!" In KDE and Gnome you'll see four numbered little squares on the taskbar. Click on one and it takes you to
that desktop. (You can have up to 10 desktops if you want.) I have on one rare occasion worked on 4 consoles and
3 desktops at the same time because of all the different stuff I was doing!
</p>

<a name="installingnasm">&nbsp;</a>
<h2>Appendix B. Installing NASM (and other stuff) on Linux</h2>
<p>
In order to install programs on your Linux system, you must be root (administrator). You can decide whether you
want to do this with the GUI utilities or in a terminal &ndash; I recommend you try both, for the added experience ;)
</p>
<h3>Using KDE / Gnome</h3>
<p>
If you're working in KDE / Gnome, installing things is fairly straightforward:
<ol>
	<li>If you are logged in as a normal user, log out and log in as root.
	<li>Pop your Linux CD in your CD-ROM drive, and it should be automounted (NASM is on the <b>2<sup>nd</sup></b> CD).
	You can then use a file manager (Konqueror, Nautilus) to go to <tt>/mnt/cdrom</tt> where you should see the
	contents of the Linux CD. If there's nothing, go to the desktop, right-click on the CD-ROM icon and click "Mount".
	<li>In <tt>/mnt/cdrom</tt>, go to <tt>RedHat</tt>, then <tt>RPMS</tt>. You should see a lot of files with the extension
	<tt>.RPM</tt> &ndash; look for <tt>nasm-0.98-8.i386.rpm</tt>.
	<li>Click/double-click on it to open it with the package manager. From there it shouldn't be too much of a
	mission to install. Also install <tt>nasm-doc-0.98-8.i386.rpm</tt>, the documentation for NASM.
</ol>
</p>

<h3>Using the Terminal</h3>
<p>
Installing stuff by means of a terminal isn't difficult either:
<ol>
	<li>If you weren't logged in as root, become root in the terminal by typing <tt class=type>su</tt>
	(for "substitute user"). After entering your password, you will now be logged in on that terminal as root.
	<li>Mount the CD-ROM by typing <tt class=type>mount /dev/cdrom</tt>
	<li>Change to the packages directory: <tt class=type>cd /mnt/cdrom/RedHat/RPMS</tt>
	<li>Install NASM with the RedHat Package Manager, by typing: <tt class=type>rpm -i nasm-0.98-8.i386.rpm</tt><br>
	(Hint: use tab-completion!)<br>
	Also install <tt>nasm-doc-0.98-8.i386.rpm</tt>, the documentation for NASM.
	<li>If you su'd to become root, type <tt class=type>exit</tt> to log out and stop being root.
</ol>

If everything was successful, congratulations! You're well on your way to becoming an elite Linux user.
If something broke, feel free to e-mail me and I'll do my best to help. Good luck, and happy hacking in Linux!
</p>

<a name="references">&nbsp;</a>
<h2>Appendix C. References</h2>
<p>
<a href="http://www.leto.net/papers/writing-a-useful-program-with-nasm.txt">Writing a useful program with NASM</a><br>
<a href="file:///usr/doc/nasm-0.98/html/nasmdoc0.html">The NASM documentation</a><br>
<a href="http://www.linuxassembly.org/intro/Assembly-Intro.html">Introduction to UNIX assembly programming</a><br>
<a href="http://www.geocities.com/SiliconValley/Ridge/2544/asm/linux-asm.txt">Linux Assembler Tutorial by Robin Miyagi</a><br>
Section 2 of the manpages
</p>

</body>
</html>